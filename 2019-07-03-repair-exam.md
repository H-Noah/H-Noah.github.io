---
title: "[요약]데이터베이스"
permalink: docs/computer-db
last_modified_at: 2019-06-27T17:58:49-04:00
excerpt: "db에 관한 지식 중 핵심만 요약한 포스트입니다."
toc: true
classes: wide
author_profile: false
sidebar:
  title: "Order List"
  nav: sidebar-sample
tags:
  - Database
  - computer

---

## 기출


### 2015


> 단답형

1. demand paging 방식에서 물리주소와 논리주소를 서로 변환
    * 예시주면서 LRU 페이지 교체알고리즘을 쓸 때, 교체될 페이지는?

2. SQL 스키마를 준 뒤, SQL을 작성하라는 5문제
    * 조인이 많아서 실수할 확률이 높다.

3. 코드를 해석하여 출력값을 적으시오.

4. 코드를 해석하여 출력값을 적으시오.

5. 재귀식을 보고 재귀트리 및 시간복잡도 구하기
    
6. 정렬방법(인서트, 힙, 머지, 퀵)의 BEST, WORST, 모든 수가 같을 때, 시간복잡도.

7. 무방향그래프의 최소간선, 최대간선 수

등



### 2016

> 단답형

1. ACID 트랜잭션에 대해 설명하라.

2. 평균 70점 이상 클래스의 최고 점수를 출력하는 SQL문을 작성하라.

3. tcp syn flooding 관련 문제

4. 코드를 주며 모듈 간 결합도를 구하라.

5. 통신 그래프?
    
6. 코드출력결과를 적고 만약 오류가 발생한다면 그 이유를 설명하라.

7. 최소신장트리, 최소경로트리에 대해 약술하라.
    

> 일반시사

1. 누진제에 대한 논술


### 2017

> 단답형

1. 화이트박스테스트의 특징을 블랙박스테스팅과 비교하여 2줄 이내로 설명하라.

2. zigbee에 대한 설명 후 어떤 기술인지 맞추기
    - 정답: zigbee
3. 해킹기법에 대한 설명 후 어떠한 해킹기법인지 맞추기
    - 정답: 스니핑 스푸핑?
4. 포인터 개념에 관한 문제
    - char*temp[3] = {"apple", "banana", "kiwi"};
    - 코드를 주며 출력값을 묻는 문제
5. (중요)해시
    - 해시함수와 숫자를 주고 충돌횟수를 묻는 문제
6. 이진트리의 preorder 값
    - 이진트리의 inorder, postorder 결과를 알려준다.
7. 자바코드 출력값 문제층
    
> 약술

1. 쿼리문 빈칸 작성
    - 부서별 월급 평균 구하는 쿼리작성
        * SELECT 부서,AVG(월급) AS avg_money from TABLE_NAME GROUP BY 부서;

2. 컴퓨터구조 관련 문제
    - 실린더, 디스크사이즈를 주며 탐색속도를 구하라.

> 논술

1. I/O, CPU context switching time을 알려준 뒤, RR 방식을 적용했을 때 효율을 구하는 문제

2. B+트리와 B트리의 차이점을 약술하라
    * 2,3,5,7,9,11,13,15 처럼 오름차순으로 데이터가 삽입될 때 B+트리의 최종 삽입 과를 그리시오


### 2018

> 단답형

1. SQL 작성문제.
    - 정답이 4줄가량되는 긴 쿼리였다고 하니 자세히 알아야 함
2. 결합도 관련 문제
3. 서브넷 문제
4. 재귀코드 관련 빈 칸 채우기
5. 복원X


> 약술

1. 플레이페어로 암호문 만들기
2. 2중포문 해석

> 논술

1. 디스크 RAID 관련 문제
2. CPU 스케쥴링 알고리즘(SJF, RR, 우선순위)

> 일반시사

1. 착한 사마리아인의 법 관련 논술









### 프로세스와 스레드

* 프로세스(Process)란 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다. 즉, 실행된 프로그램
    * 메모리에 올라와 **실행되고 있는 프로그램의 인스턴스(독립적인 개체)**  
  * 특징
    * <img src="./images/process.png" width="40%" height="40%">    
    * 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.    
* 스레드(Thread) 란 **프로세스의 특정한 수행 경로**이다. 즉,프로세스가 할당받은 자원을 이용하는 실행의 단위
  * 특징
    * <img src="./images/thread.png" width="40%" height="40%">    
    * 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
* 프로세스 VS 스레드
    * 메모리영역 (프로세스=독립, 스레드=stack만 독립)    
* 멀티프로세스 VS 멀티스레드
    ![problem](/assets/images/multi-thread.png)   
    * 멀티스레드의 장점 **프로세스 생성 시스템 콜이 적다**
    * 멀티스레드의 장점 **메모리를 공유해서 자원소모가 적다**
    * 멀티스레드의 단점 **동기화가 어렵다**



### 뮤텍스와 세마포어 (자세히 물어볼만 한듯, 문제찾기)
* 뮤텍스(Mutex, 상호배제)
    * 공유자원에 **여러 스레드가** 접근하는 것을 막는 것
    * 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 실행하게 하는 기술이다.
    * 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 synchronized 또는 lock을 사용한다.
        * 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.
* 세마포어(Semaphore)
    * 공유자원에 **여러 프로세스가** 접근하는 것을 막는 것
    * 리소스 상태를 나타내는 간단한 카운터로 생각할 수 있다.   
        * 비교적 긴 시간을 확보하는 리소스에서 이용한다.
    * 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
    * 세마포어 값은 확인하고 변경할 수 있다.
        * 1) 사용 중이지 않는 자원의 경우 그 프로세스가 즉시 자원을 사용할 수 있다.
        * 2) 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면 재시도하기 전에 일정 시간을 기다려야 한다.
        * 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.
    * 세마포어는 이진수 (0 또는 1)를 사용하거나, 또는 추가적인 값을 가질 수도 있다.
* **차이**
    1. 가장 큰 차이점은 관리하는 **동기화 대상의 개수**
        * Mutex는 동기화 대상이 오직 하나뿐일 때, Semaphore는 동기화 대상이 하나 이상일 때 사용한다.
    2. Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없다.
        * Mutex는 상태가 0, 1 두 개 뿐인 binary Semaphore
    3. Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 가진다.
        * Mutex 의 경우 상태가 두개 뿐인 lock 이므로 lock 을 가질 수 있다.
    4. Mutex의 경우 Mutex를 소유하고 있는 스레드가 이 Mutex를 해제할 수 있다. 하지만 Semaphore의 경우 이러한 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.
    5. Semaphore는 시스템 범위에 걸쳐있고 파일시스템상의 파일 형태로 존재하는 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up 된다.


### 교착상태의 개념과 조건 (자세히 물어볼만 한듯, 문제찾기)
* 교착상태(데드락, Deadlock)란
  * 모든 스레드가 서로 풀리기를 기다리고 있는 상황으로 무한 대기 상태에 빠진다. 이런 스레드를 교착상태에 빠졌다고 한다.
* 교착상태의 4가지 조건
  1. 상호 배제(mutual exclusion)
      * 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.
      * 좀 더 정확하게는, 공유 자원에 대한 접근 권한이 제한된다. 자원의 양이 제한되어 있더라도 교착상태는 발생할 수 있다.
  2. 들고 기다리기(hold and wait) = **점유대기**
      * 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.
  3. 선취 불가능(Non Preemptive) = **비선점**
      * 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.
  4. 대기 상태의 사이클(circular wait) = **순환대기**
      * 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.
* 교착상태 방지
  * 4가지 조건들 가운데 하나를 제거하면 된다.
  * 공유 자원 중 많은 경우가 한 번에 한 프로세스만 사용할 수 있기 때문에(예를 들어, 프린트) 1번 조건은 제거하기 어렵다.
  * 대부분의 교착상태 방지 알고리즘은 4번 조건, 즉 대기 상태의 사이클이 발생하는 일을 막는 데 초점이 맞춰져 있다.
