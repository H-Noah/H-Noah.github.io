---
title: "[풀이]백준 풀이(VI/16929), SW EA(1249)"
permalink: docs/solve(VI)
last_modified_at: 2019-03-18T17:58:49-04:00
excerpt: "BOJ 16929 등 다수의 잡 문제 풀이"
toc: true
classes: wide
author_profile: false
sidebar:
  title: "Order List"
  nav: sidebar-sample
tags:
  - algorithm
  - coding

---


## 문제풀이

### [RE]Two Dots(16929, DFS, O(N*M))

- 사이클의 정의 (같은 색, 4개 이상 연결된 점들의 집합)
- 즉, 임의의 점에서 시작해서 길이가 4이상인 <mark>도착점(자기자신)</mark>이 있는지만 확인.
- DFS, BFS 모두 가능.

> 풀이1. **마지막 정점**에서 find를 한 뒤 **이미 방문했던 같은 색상의 점**이 있다면 사이클이 존재. (일단 갔던 곳도 방문을 해 본 뒤, 뺄셈)

> 풀이2. 이전 칸과 다른 칸만 방문해서 이미 방문했던 곳으로 돌아오게 될 경우 사이클은 무조건 존재한다.

**TIP:** 다른 점에서 DFS를 다시 시작 할 경우 CHECK배열을 초기화할 필요가 없다.(사이클이 있었으면 이미 끝났고 다시 본다고 해도 사이클이 생기지도 않음).
{: .notice--warning}

> 회고

1. 좀 다른 방식으로 푼 것 같다.
2. 수업 내용 중 `중복`을 줄이기 위해 이미 갔던곳은 반복하지 않는 경우가 있었던 것이 기억나 memset을 안해서 답이 틀렸었다.

YYYR   
BYBY    
BBBY    
BBBY   

의 경우 (1,0)의 B에서 시작하면 마지막 조건문 `sx==cx && sy==cy`에 걸리지 않고 다른 점들을 모두 방문한 노드로 변경해버렸었다..

디버깅은 참 좋은 기능이다.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

int n, m, sx, sy;
bool check[51][51];
char map[51][51];
bool fin;
int dx[] = {0,  0, 1, -1 };
int dy[] = {1, -1, 0,  0 };

void dfs(int x, int y, char color, int count){

	if(fin) return;
	for(int i=0; i<4; i++){
		int cx = x + dx[i];
		int cy = y + dy[i];
		if(cx>=0 && cx<n && cy>=0 && cy<m)
		{
			if(!check[cx][cy])
			{
				if(map[cx][cy] == color)
				{
					check[cx][cy] = true;
					dfs(cx,cy, color, count+1);
				}
			}
			else
			{
				if(count >=4 && sx == cx && sy ==cy)
				{
					fin = true;
					return;
				}
			}

		}
	}
}

int main(){
	cin >> n >> m;

	//입력
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			char a;
			cin >> a;
			map[i][j] = a;
		}
	}
	//dfs 실행
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			memset(check, false, sizeof(check));
			sx = i; sy = j;
			check[i][j]=true;
			int cnt =1;
			dfs(i,j, map[i][j], cnt);
			if(fin)
			{
				cout<<"Yes"<<endl;
				return 0;
			}
		}
	}
	cout << "No" << endl;
	return 0;
}


```


### 4일차 - 보급로

- N*N 2차원 배열 (N<=100)
- 출발지(S)에서 도착지(G)로 가기위한 도로 복구
- 배열의 값 만큼 복구에 시간이 소요
- 가장 짧은 경로에 대한 총 복구 시간을 구하라
- 이동은 상/하/좌/우로 가능하며 현재 칸의 도로를 복구해야만 다른 곳으로 갈 수 있다.

가중치가 다른 그래프이므로 다익스트라 알고리즘을 사용하자.

1. 출발 노드의 인덱스 = start
2. start에서 i번째 노드까지 가는 최소거리값 = dist[i]
3. 방문한 노드의 배열 check (start to i까지의 최단거리가 이미 구해짐)
-

> 풀이 방법

1. 배열 dist를 INF(987654321)로 초기화한다. 단, 시작 노드는 0이므로 dist[start] = 0이다.

2. 아래 루프를 반복한다
	
	1. 배열 d중에서 최소값을 가지고 있는 N번째 노드(단, S[N]은 false)를 ‘방문’한다. 즉, S[N]=true로 초기화 시켜준다.

	2.  이 때 방문하지 않은 노드 중에 최소값을 가지고 있는 노드가 거리가 무한대라면(즉, S[N]이 false인 모든 d[N]이 무한대라면), 방문하지 않은 노드들은 전부 절대 ‘방문’ 할 수 없는 노드란 것을 의미하거나 (만약 방문할 수 있었다면 이전의 3) 단계에서 d[N]이 무한대보다는 작은 값으로 업데이트 되었을 것이기 때문이다.), 모든 노드를 방문했다는 의미이기 때문에, 반복문을 빠져나간다.

	3. N번째 노드를 ‘방문’하면, 배열 d를 순회하며 ‘N번째 노드를 통해서 가는 거리가 더 짧은 지’ 확인하고, 더 짧다면, 배열 d를 더 짧은 거리(N번째 노드를 통해서 가는 거리)로 초기화 시켜준다.