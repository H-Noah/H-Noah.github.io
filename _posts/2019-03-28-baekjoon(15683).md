';---
title: "[풀이]백준 풀이(XIII/15683 등)"
permalink: docs/solve(XIII)
last_modified_at: 2019-03-28T17:58:49-04:00
excerpt: "BOJ 15683

 등 다수의 잡 문제 풀이"
toc: true
classes: wide
author_profile: false
sidebar:
  title: "Order List"
  nav: sidebar-sample
tags:
  - algorithm
  - coding

---


## 문제풀이


### 감시(15683, 시뮬레이션)

- N*M 형태의 이차원 배열
- CCTV는 5가지 종류(1한방향, 2양쪽방향, 3직각방향, 4세방향, 5네방향)
- 6은 벽이다.
- 사무실의 크기와 상태, CCTV가 주어졌을 때 CCTV의 방향을 적절히 정해서 최소 사각지대의 크기를 구하는 프로그램을 작성하라.

- 1<=N,M <=8
- CCTV는 8개를 넘지 않는다.

> 풀이

- 중복순열이 필요하다 (next_permutation은 그냥 순열!)
- [백준15651](https://www.acmicpc.net/problem/15651) 참조!
- 외울게 늘었네 ㅎㅎ.. (DFS를 이용한 순열구하기!)

> DFS를 짜되 VISITED를 표시하지 않으면 된다.

> 문법...헷갈려 아래 둘은 같은 뜻

```c++
      for (auto i : vc)
          printf("%d ", i);
      printf("\n");
      return;

        int size = vc.size();
    
    	for(int i=0; i<size; i++){
    		cout << vc[i] << " ";
    	}
    	cout << endl;
    	return;
    
```


중단

what the fuck

4 6
0 0 0 1 0 1
6 6 6 0 6 6
0 0 0 1 6 6
6 6 6 0 6 6


```c++

#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <tuple>
#include <algorithm>

#define NEWS 4
#define INF 987654321
using namespace std;

int cx, cy;
int n, m, cctv, Answer=INF;
int office[9][9];
int officeTemp[9][9];
vector<int> vc;
//<type, cx, cy>
queue<tuple<int,int,int>> tv;
queue<tuple<int,int,int>> tvTemp;
queue<int> rotateInfo;


void watchLeft(int x, int y){
	for(int i=cy; i>=0; i--){
		//벽이면 끝내
		if(office[x][i]==6) i=-1;
		//아니면 -1(#)으로 채우자
		else if(office[x][i]==0)  office[x][i]=-1;
	}
}
void watchRight(int x, int y){
	for(int i=cy; i<m; i++){
		//벽이면 끝내
		if(office[x][i]==6) i=m;
		//아니면 -1(#)으로 채우자
		else if(office[x][i]==0)  office[x][i]=-1;
	}
}
void watchUp(int x, int y){
	for(int i=cx; i>=0; i--){
		//벽이면 끝내
		if(office[i][y]==6) i=-1;
		//아니면 -1(#)으로 채우자
		else if(office[i][y]==0)  office[i][y]=-1;
	}
}
void watchDown(int x, int y){
	for(int i=cx; i<n; i++){
		//벽이면 끝내
		if(office[i][y]==6) i=n;
		//아니면 -1(#)으로 채우자
		else if(office[i][y]==0)  office[i][y]=-1;
	}
}

void makeBlindSpot(int type, int degree){
	//degree 1=90 2=180 3=270 4=360

//	cout << "cx is " << cx << endl;
//	cout << "cy is " << cy << endl;
//	cout << "type is " << type << endl;
//	cout << "degree is " << degree << endl;
//
//    for(int i=0; i<n; i++){
//    	for(int j=0; j<m; j++){
//    		cout << office[i][j] << " ";
//    	}
//    	cout << endl;
//    }


	if (type==1)
	{
		//R
		if(degree==1)watchRight(cx,cy);
		//D
		if (degree==2)watchDown(cx,cy);
		//L
		if (degree==3)watchLeft(cx,cy);
		//U
		if (degree==4)watchUp(cx,cy);

	}
	if (type==2)
	{
		//LR
		if(degree%4==1){
			watchLeft(cx,cy);
			watchRight(cx,cy);
		}
		//UD
		if (degree%4==2){
			watchUp(cx,cy);
			watchDown(cx,cy);
		}

	}
	if (type==3)
	{
		//UR
		if(degree==1){
			watchUp(cx,cy);
			watchRight(cx,cy);
		}
		//RD
		if (degree==2){
			watchRight(cx,cy);
			watchDown(cx,cy);
		}
		//DL
		if (degree==3){
			watchDown(cx,cy);
			watchLeft(cx,cy);
		}
		//LU
		if (degree==4){
			watchLeft(cx,cy);
			watchUp(cx,cy);
		}

	}

	if (type==4)
	{
		//LUR
		if(degree==1){
			watchLeft(cx,cy);
			watchUp(cx,cy);
			watchRight(cx,cy);
		}
		//URD
		if (degree==2){
			watchUp(cx,cy);
			watchRight(cx,cy);
			watchDown(cx,cy);

		}
		//RDL
		if (degree==3){
			watchRight(cx,cy);
			watchDown(cx,cy);
			watchLeft(cx,cy);
		}
		//DLU
		if (degree==4){
			watchDown(cx,cy);
			watchLeft(cx,cy);
			watchUp(cx,cy);
		}
	}
}


void findBlindSpot(){
	int compAns=0;
	int type;
	int degree;


	while(!rotateInfo.empty())
	{
		//tv = cctv 종류 && 위치
		//rotateInfo = 회전(방향) (1 = 90, 2 = 180, 3 = 270)
		tuple<int,int,int> k = tv.front();
		tie(type, cx, cy) = k;
		degree = rotateInfo.front();





		if(cx==2 && cy==3 && type==1 && degree==3){
			for(int i=0; i<n; i++){
				for(int j=0; j<m; j++){
					if(office[i][j]==0) compAns++;
				}
			}
		}
		if(type!=6)	makeBlindSpot(type, degree);

		//큐에서 빼고
		tv.pop();
		rotateInfo.pop();
	}

	//tv 비워보자..
	while(!tv.empty()){
		tv.pop();
	}

	//사각지대를 찾고

	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			if(office[i][j]==0) compAns++;
		}
		cout << endl;
	}


	//최소값 갱신
	Answer = min(Answer, compAns);

	//tv 갱신
    for(int i=0; i<n; i++){
    	for(int j=0; j<m; j++){
    		office[i][j] = officeTemp[i][j];
    		if(office[i][j]>0 && office[i][j]!=6){
    			tv.push(tuple<int,int,int>(office[i][j],i,j));
    		}
    	}
    }

}

void dfs()
{
	//예외1 만약 현재최소값이 0이면 더작아질 수 없으므로 끝낸다.

	if(office[cx][cy]==6){
		return;
	}


	if(Answer==0) {
		return;
	}



	//cctv 개수
	cctv = tv.size();
	int size = vc.size();
    if (size == cctv)
    {
    	//회전정보 저장
    	for(int i=0; i<size; i++){
    		rotateInfo.push(vc[i]);
    	}
    	//사각지대를 찾는다.
    	findBlindSpot();
    	return;
    }

    for (int i = 1; i <= NEWS; i++)
    {
        if (size < cctv)
        {
            vc.push_back(i);
            dfs();
            vc.pop_back();
        }
    }
}


int main()
{
	int Atemp=0;
	ios_base::sync_with_stdio(NULL);
	cin.tie(NULL);

    cin >> n >> m;

    for(int i=0; i<n; i++){
    	for(int j=0; j<m; j++){
    		cin >> office[i][j];
    		//카메라가 없는 경우를 대비하여 미리 처리
    	}
    }


    //5 미리계산

    for(int i=0; i<n; i++){
    	for(int j=0; j<m; j++){
			if(office[i][j]==5) {
				watchUp(i,j);
				watchRight(i,j);
				watchDown(i,j);
				watchLeft(i,j);
			}
    	}
    }

    for(int i=0; i<n; i++){
    	for(int j=0; j<m; j++){
    		officeTemp[i][j] = office[i][j];

    		if(office[i][j]==0) Atemp++;
    		if(office[i][j]>0){
    			if(office[i][j]!=6)	tv.push(tuple<int,int,int>(office[i][j],i,j));
    		}

    	}
    }

	Answer = min(Atemp, Answer);
	cout << Answer << " ";

    dfs();

    cout << Answer;
    return 0;
}

```