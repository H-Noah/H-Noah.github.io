---
title: "[TO-DO-LIST]PREPARE-FOR-KSD-3"
permalink: docs/to-do-list-KSD-d
last_modified_at: 2019-07-10T17:56:49-04:00
excerpt: "소프트웨어공학에 대해 다룹니다."
toc: true
classes: wide
author_profile: false
sidebar:
  title: "Order List"
  nav: sidebar-sample
tags:  
  - software engineering

---

완료 후, ~~취소선~~으로 표시하며 하나씩 제거합니다.   

이 강의는 K-MOOC의 동국대학교 소프트웨어공학 강의를 참조했습니다. 

## 소프트웨어공학

### 0장 강의소개

* 일반적인 개발단계
  * 분석: 시스템을 위하여 무엇을 만들 것인가? (요구사항 명세서)
  * 설계: 시스템을 어떻게 구축할 것인가? (설계 명세서)
  * 구현: 시스템의 코딩과 단위 시험(새 시스템, 유지보수 계획)
  * 테스팅: 시스템이 요구에 맞게 실행되는가? (테스팅 결과 보고서)

### 1장 소프트웨어 개발 프로세스


* 통합 & 테스트
  * 통합은 개발자가 주로 담당하며 테스트는 QA팀이 주로 담당한다.
  * 단계적인 테스트는 단위, 통합 테스트가 있다.
  * 목적중심 테스트는 스트레스, 성능, 베타 테스트 등이 있다.  
  
  
![problem](/assets/images/prepare-for-KSD-4.PNG)


* Code-and-Fix
  * 중요한 작업(설계, 테스트)이 무시될 수 있다.
  * 대규모 작업에는 적합하지 않다.
  * 문제가 늦게 발견될수록 Cost가 커진다.

* Water fall
  * 적용:
    * 이미 잘 알고 있는 문제나 연구중심 문제
    * 변화가 적은 프로젝트에 적합
  * 장점:
    * 단순한 프로세스, 쉬운 관리
  * 단점:    
    * 프로토타입, 재사용의 기회가 적다.

* prototyping
  * 적용:
    * 개발착수시점에 요구사항이 불분명한 경우
    * 실험적, 혁신적 기술 사용 시
  * 장점:
    * 사용자의 의견반영이 잘 되며 설명하기 쉽다.
  * 단점:    
    * 관리가 난해하다.

* Spiral
  * 적용:
    * 재정적, 기술적 위험부담이 큰 경우
  * 장점:
    * 대규모 개발에 적합하며 한 사이클에 추가하지 못한 기능은 다음단계에 추가 가능하다.
  * 단점:    
    * 관리가 어렵고 위험분석이 중요하다

* V
  * 적용:
    * 신뢰성이 높이 요구되는 분야
  * 장점:
    * 오류를 줄일 수 있다.
  * 단점:    
    * 반복이 없으므로 변경하기 쉽지않다.
  
* 프로세스 모델에 관한 시험문제  
  * 자동차의 ABS를 설계하기 위한 소프트웨어 모델은?
    * V모델: 오류를 줄여 신뢰성을 높일 수 있으므로 적절하다.
  * 병원에서 현재 사용하는 회계시스템을 대체하기 위한 새 시스템
    * Waterfall 모델: 이미 알고있는 문제를 개발할 때 적합하므로
  * 항공기 승객이 비행기를 놓쳤을 때 빠르게 대체항공편을 찾을 수 있게하는 대화형 시스템
    * .. 잘모르겠다.
  

### 2장 요구분석

### 3장 구조적 분석

### 4장 객체지향 분석

* 절차지향 프로그래밍(Old way, c프로그래밍)
  * 시스템이 함수의 집합
  * 함수가 서로 자료를 주고 받는다.
  * 함수와 자료가 분리되어있으며 재사용이 어렵다

* 객체지향 프로그래밍(New way, JAVA)
  * 프로그램은 클래스의 집합
  * 클래스는 객체를 정의한 템플릿 (객체들이 갖는 자료와 오퍼레이션을 정의한 것)
  * 객체는 클래스의 인스턴스

* 상속관계
  * 일반적 개념의 클래스와 더 구체적 클래스의 관계(A kid of)
  * 다중상속: 두 개 이상의 베이스클래스를 가지는 관계

![problem](/assets/images/prepare-for-KSD-5.PNG)

### 5장 Use Case

* Use case 
  * 액터: 사용자
  * Attribute: 객체가 갖는 데이터 필드
  * operation: 간단한 메소드, 상속메소드를 생략한 메소드
  * extends: 예외 사항을 나타내는 관계
  * includes: 사용사례 사이의 중복 제거

### 6장 UML 클래스 다이어그램

* UML(Unified Modeling Language)
  * 시스템에 대한 지식을 표현하기 위한 언어
  
* 클래스 다이어그램
  * 객체지향시스템에 존재하는 클래스, 필드, 메소드 등의 관계를 나타내는 다이어그램
  * 단, 알고리즘, 동작방법 등은 표현하지 않는다.
  * Generalization: 상속관계, 부모를 향한 화살표
  * association: 임의의 클래스의 인스턴스가 작업실행을 위해 다른 클래스를 알아야 하는 경우
  * aggregation: contains, 빈 다이아몬드
  * composition: aggregation 보다 끈끈한 관계, 채운다이아몬드
  * dependency: 일시적 사용, 점선표시

### 7장 UML 시퀀스 다이어그램

* Sequence Diagram
  * 사용 사례가 어떻게 수행되는지 나타낸 그림
  * 메세지는 직선, 리턴값은 점선으로 표시한다.

### 8장 동적 모델링

### 10장 UI 디자인

### 11장 디자인 패턴

..

### (매우중요)결합도

* 모듈화의 정의
  * 시스템을 분해하고 추상화하여 소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합이 용이하도록 하는 소프트웨어 설계기법.
  * 소프트웨어를 기능별로 분할하는 것을 의미하며 각 기능을 모듈이라고 한다.

* 모듈화의 목표
  * 모듈 간 결합도의 최소화
  * 모듈 내 요소들 간의 응집도 최대화

* 결합도(Coupling)
  * 모듈간에 상호 의존하는 정도
  * 모듈 상호간 결합도를 낮추어 서로 의존하는 모듈이 적어야 한다.
  * **내용결합도 - 공통결합도 - 제어결합도 - 스탬프결합도 - 자료결합도** 순으로 결합도가 강하다.
    (내 공재 쓰자)

* (중요) 자료 결합도(Data Coupling)
  * 한 모듈이 다른 모듈을 호출할 때, 필요한 자료만을 매개변수로 전달하여 참조하는 경우

  * **(불분명)** 예시) [감리사-2014-49] 다음과 같은 C 프로그램이 주어졌을 때, 모듈 abc와 모듈 def 간의 결합도와 모듈 def의 응집도를 가장 적절하게 나타낸 것은?
    
  ```c
  void abc(void) {     
        int a, b, in;     
        int res;     
        scanf("%d %d %d", &a, &b, &in);     
        res = def(a, b, in);
        printf("result = %d\n", res);
  }
  
  int def(int x, int y, int v) {     
        if(v > 0) {        
              return(x+y);
        } 
        else {        
              return(x-y);
        }
  }
  ```

  * 정답: 자료 결합도(Data Coupling), 교환적 응집도(Communication cohesion)
  
* (중요) 스탬프 결합도(Stamp Coupling)
  * 두 모듈이 동일한 복합 자료구조(배열, 구조체 등)를 매개변수로 전달하여 참조하는 경우
  * 예시) [감리사-2011-28] 다음 코드에서 함수의 결합도는?
  ```c
  struct {
        int x, y;
  } X;
  
  int doSomething(struct X p) {
        return p.x + p.y;
  } 
  ```
  * 정답: 스탬프(stamp) 결합도


* (중요) 제어 결합도(Control Coupling)
  * 한 모듈이 다른 모듈의 내부에서 작용하는 논리적 흐름을 제어하기 위해서 제어 플래그나 정보를 매개변수로 전달하는 경우

    ```c
    void setValue(String name, int value) 
    {   
          if ( name.equals(“height”) ) {
                height = value ;   
          }   
          
          if ( name.equals(“width”) ) {
                width = value ;
          }
    }
    
    void setHeight(int arg) {   _height = arg ; }
    void setWidth(int arg) {   _width = arg ; }
   ```

  * 정답: 제어 결합도(Control Coupling), 논리적 응집도(logical cohesion)

* 외부 결합도(External) Coupling)
  * 모듈들이 외부환경(OS, 컴파일러 등)과 연관되어 있는 경우


* (중요) 공통 결합도(Common Coupling)
  * 모듈들이 동일한 자료영역(전역변수)을 공통으로 조회하는 경우
  * 오류 발생 시, 타 모듈로 전파 가능성이 큼
  * 예시) [감리사-2012-45] 다음 코드에서 함수의 결합도는?
    ```c
    int xyz = 0; 
    int doSomething(int delta) {   
          xyz += delta;   
          return xyz;
    }
   ```


  * 정답: 제어 결합도(Control Coupling), 논리적 응집도(logical cohesion)

* (중요) 내용 결합도(Contents Coupling)
  * 한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조하거나 수정하는 경우
  * 한 모듈에서 다른 모듈의 중간으로 분기되는 경우도 해당된다.


### (매우중요)응집도(Cohesion)

* `하나의 모듈 내부의` 처리요소들 간의 기능적 연관성을 측정하는 척도
* 따라서 독립적인 모듈이 되기 위해서는 각 모듈의 응집도가 강해야한다.

* 기능적 응집도(Functional Cohesion)
  * 모듈 내부의 모든 기능요소들이 단일문제와 연관되어 수행될 경우
  * 예시) 코사인 계산 함수

* 순차적 응집도(Sequential Cohesion)
  * 한 활동의 출력이 다음 활동의 입력으로 사용
  * 예시) 파일에서 데이터를 읽고 데이터를 처리하는 기능

* (중요)통신적 응집도(Communicational Cohesion)
  * 서로 다른 기능이 동일자료를 사용하나 처리순서는 상관없음
  * 모듈의 모든 기능이 동일한 자료구조를 참조하거나 업데이트하는 경우
  * 배열 또는 스택에 정의된 함수집합. (pop(), push()..? )

* 절차적 응집도(Procedural Cohesion)
  * 모듈이 다수의 관련 기능을 가질 경우 모듈 안의 구성요소들이 그 기능을 순차적으로 수행하는 경우
  * 관련없는 기능요소가 배열된 순서로 수행되는 것으로 한 모듈내의 활동들이 순차적으로 수행한다.

* 논리적 응집도(Logical Cohesion)
  * 논리적으로 유사한 기능을 수행하지만 서로의 관계는 밀접하지 않음
  * 모든 마우스 및 키보드 입력처리 루틴 그룹화
  * 예시)   [감리사-2010-32] 다음 코드에서 사용된 함수의 응집도는?
  ```c  
  void readWrite(int type, int* data, int size) {
        switch(type) {
              0: read(data, size);
              break;
              
              1: write(data, size);
              break;
        }
  }
  ```




