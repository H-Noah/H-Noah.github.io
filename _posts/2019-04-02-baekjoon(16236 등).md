---
title: "[풀이]백준 풀이(XV/11729 등)"
permalink: docs/solve(XV)
last_modified_at: 2019-04-01T17:58:49-04:00
excerpt: "BOJ 11729 등 다수의 잡 문제 풀이"
toc: true
classes: wide
author_profile: false
sidebar:
  title: "Order List"
  nav: sidebar-sample
tags:
  - algorithm
  - coding

---


## 문제풀이

### 아기상어(16236, 시뮬레이션 & BFS)

``` c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <tuple>

#define INF 987654321

using namespace std;
int map[21][21];
int Answer = 0;
int n, jawsSize = 2, currentJawsX, currentJawsY, currentFishX, currentFishY;
int eaten = 0, minDist = INF, minDistTemp, compare;
int dx[] = { 0, 0, -1, 1 };
int dy[] = { 1,-1,  0, 0 };
int bfsDist[21][21];
bool visited[21][21];
queue<pair<int, int>> nxt;

void init() {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			map[i][j] = -1;
			bfsDist[i][j] = -1;
			visited[i][j] = false;
		}
	}
}
bool isSizeup() {
	if (eaten == jawsSize) return true;
	else return false;
}
bool isInside(int x, int y) {
	if (x >= 0 && y >= 0 && x < n && y < n) return true;
	else return false;
}
bool isEmpty() {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (map[i][j] > 0) {
				//상어가 아닌 0이상의 정수(물고기)가 하나라도 있으면 false
				if (map[i][j] != 9) return false;
			}
		}
	}
	return true;
}
bool isNext(int origin, int compare) {
	//비교한 거리가 더 가까우면 후보변경
	if (origin >= compare) return true;
	else return false;
}
int calcDist(int i, int j) {
	//상어와 물고기의 맨하탄 디스탄스 리턴
	int x = abs(currentJawsX - i);
	int y = abs(currentJawsY - j);
	return x + y;
}
//물고기를 찾는다.
//만약 없다면-> 엄마상어 호출 or 다먹은 경우(isEmpty)
//만약 있다면-> 어떤 물고기 먹을지 고르는 함수();
//반복주기 -> findFish() -> selectFish() -> isSizeup()
void printMap() {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << map[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
}
void bfs(int sx, int sy) {
	queue<pair<int, int>> q;
	q.push(make_pair(sx, sy));
	visited[sx][sy] = true;
	while (!q.empty()) {
		int cx = q.front().first;
		int cy = q.front().second;
		q.pop();
		for (int i = 0; i < 4; i++) {
			int nx = cx + dx[i];
			int ny = cy + dy[i];
			//방문한 적 없고,
			if (!visited[nx][ny] && isInside(nx, ny)) {
				//지나갈 수 있으면
				if (jawsSize >= map[nx][ny]) {
					q.push(make_pair(nx, ny));
					visited[nx][ny] = true;
					bfsDist[nx][ny] = bfsDist[cx][cy] + 1;
				}
			}
		}
	}
}
void selectFish() {
	minDist = INF;
	minDistTemp = minDist;
	//init visited;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			visited[i][j] = false;
			bfsDist[i][j] = 0;
		}
	}
	bfs(currentJawsX, currentJawsY);

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			//물고기이고
			if (map[i][j] > 0) {
				//상어가아니고
				if (map[i][j] != 9) {
					//상어보다 작은 물고기이며 범위안이며니
					if (map[i][j] < jawsSize) {
						if (isInside(i, j)) {
							//만약 [i][j]를 갈 수 잇으면
							if (visited[i][j]) {
								//거리를 계산한 뒤
								//가까운지를 확인하고(거리가 작거나 같음)
								if (minDist > bfsDist[i][j]) {
									//거리의 최소값을 갱신한다.
									minDist = min(minDist, bfsDist[i][j]);
									//만약 거리가 작다면 잡아먹을 물고기후보 변경!
									currentFishX = i;
									currentFishY = j;
								}
								//만약 이전 최소와 거리가 같다면
								else if (minDist == bfsDist[i][j]) {
									//가장 위인지 비교 
									//만약 다음물고기가 더 위라면
									if (currentFishX > i) {
										currentFishX = i;
										currentFishY = j;
									}
									//만약 둘의 높이가 같다면
									else if (currentFishX == i) {
										//좌 우를 비교하여 잡아먹을 물고기후보 변경!
										if (currentFishY > j) {
											currentFishX = i;
											currentFishY = j;
										}
									}
								}
							}
						}
						//예외(거리1)
					}
				}
			}
		}
	}
}

void findFish(int x, int y, int size) {
	currentJawsX = x;
	currentJawsY = y;
	//물고기위치도 처음위치로 가자.
	currentFishX = INF;
	currentFishY = INF;
	if (isEmpty()) {
		return;
	}
	//사이즈가 커져야하면
	if (isSizeup()) {
		jawsSize++;
		eaten = 0;
	}

	//모든점을 돌아 최소거리의 물고기를 선택한 상태
	selectFish();
	//다 돌았는데 고를 수 있는 물고기가 없다?
	if (INF == currentFishX && INF == currentFishY) {
		return;
	}
	else {
		Answer += bfsDist[currentFishX][currentFishY];
		//원래 상어가 있던 자리를 0으로 변경하고
		map[currentJawsX][currentJawsY] = 0;
		//물고기 잡아먹기
		currentJawsX = currentFishX;
		currentJawsY = currentFishY;

		//상어 위치변경과 먹은 수 증가
		map[currentJawsX][currentJawsY] = 9;
		eaten++;
		//새로 탐색
		findFish(currentJawsX, currentJawsY, size);
	}
}

int main() {

	cin >> n;
	//초기화
	init();
	int x, y;
	//우선순위  크기 > 거리 > 높이 > 왼쪽
	//상어크기는 자신과 크기가 같은 수의 물고기를 먹을 때 1증가한다.
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> map[i][j];
			if (map[i][j] == 9) {
				x = i;
				y = j;
			}
		}
	}
	findFish(x, y, jawsSize);
	cout << Answer << endl;
}
```


### 유기농 배추(1012, BFS)

- 지렁이는 배추근처에 서식하며 해충을 잡아먹는다.
- 어떤 배추에 지렁이가 있는 경우 지렁이는 인접한 칸으로 이동할 수 있다. (상,하,좌,우)
- 배추들이 곳곳에 퍼져있을 때 필요한 지렁이의 최소마리수

> 풀이

단순 그룹화를 하는 문제이다. ezez

```c++
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;

int test_case, m, n, k,group=0;
int map[51][51];
int dist[51][51];
int dx[] = {0, 0, 1, -1};
int dy[] = {1,-1, 0,  0};
bool visited[51][51];

bool isInside(int x, int y){
	if(x>=0 && y>=0 && x<n && y<m) return true;
	else return false;
}
void init(){
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			map[i][j] = 0;
			dist[i][j] = 0;
			visited[i][j] = false;
			group = 0;
		}
	}
}
void printMap(){
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			cout << map[i][j] << " ";
		}
		cout << endl;
	}
}

void bfs(int sx, int sy){
	queue<pair<int,int>> q;
	q.push(make_pair(sx,sy));
	visited[sx][sy] = true;

	while(!q.empty()){
		int cx, cy;
		cx = q.front().first;
		cy = q.front().second;
		q.pop();
		for(int i=0; i<4; i++){
			int nx = cx + dx[i];
			int ny = cy + dy[i];
			if(!visited[nx][ny] && map[nx][ny]==1 && isInside(nx,ny)){
				q.push(make_pair(nx,ny));
				visited[nx][ny]=true;
			}
		}
	}
}
int main(){
	cin >> test_case;
	for(int i=0; i<test_case; i++){
		//초기화
		init();
		//m=가로길이, n=세로길이, k=배추 갯수
		cin >> m >> n >> k;

		//배추 세팅
		for(int a=0; a<k; a++){
			int x, y;
			cin >> x >> y;
			map[y][x] = 1;
		}

		for(int a=0; a<n; a++){
			for(int b=0; b<m; b++){
				if(map[a][b]>0 && !visited[a][b]) {
					bfs(a,b);
					group++;
				}
			}
		}
		cout << group << endl;
	}
}

```

### [RE]경로 찾기(11403, DFS/BFS)

- 가중치 없는 방향 그래프 G
- 모든 정점(i,j)에 대해 i to j가 가능한지 구하는 프로그램을 작성

> 회고

- BFS로 하다가 뻘짓을 많이했다..
- DFS가 훨씬 편한데.. BFS로 다시 풀어보긴하자


```c++
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;

int n;
int graph[100][100];
int visited[100];
int result[100][100];

void initVisit(){
	for(int i=0; i<n; i++){
		visited[i]=0;
	}
}
void init(){
	for(int i=0; i<n; i++){
		for(int j=0; j<n; j++){
			graph[i][j] = 0;
			result[i][j] = 0;
		}
	}
}
//반복을 많이하네
void dfs(int s){
	for(int i=0; i<n; i++){
		if(graph[s][i]>0 && !visited[i]){
			visited[i]++;
			dfs(i);
		}
	}
}
int main(){
	ios_base :: sync_with_stdio(false);
	cin.tie(NULL);


	cin >> n;
	for(int i=0; i<n; i++){
		for(int j=0; j<n; j++){
			cin >> graph[i][j];
		}
	}

	for(int i=0; i<n; i++){
		initVisit();
		dfs(i);

        for(int j=0;j<n;j++){
            if(visited[j])
                graph[i][j]=1;
        }
	}

	cout << "\n";
	for(int i=0; i<n; i++){
		for(int j=0; j<n; j++){
			cout << graph[i][j] << " ";
		}
		cout << "\n";
	}
}
```
