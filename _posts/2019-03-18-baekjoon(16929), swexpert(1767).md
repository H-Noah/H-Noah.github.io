---
title: "[풀이]백준 풀이(VI/16929), SW EA(1767)"
permalink: docs/solve(VI)
last_modified_at: 2019-03-18T17:58:49-04:00
excerpt: "BOJ 16929 등 다수의 잡 문제 풀이"
toc: true
classes: wide
author_profile: false
sidebar:
  title: "Order List"
  nav: sidebar-sample
tags:
  - algorithm
  - coding

---


## 문제풀이

### [RE]Two Dots(16929, DFS, O(N*M))

- 사이클의 정의 (같은 색, 4개 이상 연결된 점들의 집합)
- 즉, 임의의 점에서 시작해서 길이가 4이상인 <mark>도착점(자기자신)</mark>이 있는지만 확인.
- DFS, BFS 모두 가능.

> 풀이1. **마지막 정점**에서 find를 한 뒤 **이미 방문했던 같은 색상의 점**이 있다면 사이클이 존재. (일단 갔던 곳도 방문을 해 본 뒤, 뺄셈)

> 풀이2. 이전 칸과 다른 칸만 방문해서 이미 방문했던 곳으로 돌아오게 될 경우 사이클은 무조건 존재한다.

**TIP:** 다른 점에서 DFS를 다시 시작 할 경우 CHECK배열을 초기화할 필요가 없다.(사이클이 있었으면 이미 끝났고 다시 본다고 해도 사이클이 생기지도 않음).
{: .notice--warning}

> 회고

1. 좀 다른 방식으로 푼 것 같다.
2. 수업 내용 중 `중복`을 줄이기 위해 이미 갔던곳은 반복하지 않는 경우가 있었던 것이 기억나 memset을 안해서 답이 틀렸었다.

YYYR   
BYBY    
BBBY    
BBBY   

의 경우 (1,0)의 B에서 시작하면 마지막 조건문 `sx==cx && sy==cy`에 걸리지 않고 다른 점들을 모두 방문한 노드로 변경해버렸었다..

디버깅은 참 좋은 기능이다.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

int n, m, sx, sy;
bool check[51][51];
char map[51][51];
bool fin;
int dx[] = {0,  0, 1, -1 };
int dy[] = {1, -1, 0,  0 };

void dfs(int x, int y, char color, int count){

	if(fin) return;
	for(int i=0; i<4; i++){
		int cx = x + dx[i];
		int cy = y + dy[i];
		if(cx>=0 && cx<n && cy>=0 && cy<m)
		{
			if(!check[cx][cy])
			{
				if(map[cx][cy] == color)
				{
					check[cx][cy] = true;
					dfs(cx,cy, color, count+1);
				}
			}
			else
			{
				if(count >=4 && sx == cx && sy ==cy)
				{
					fin = true;
					return;
				}
			}

		}
	}
}

int main(){
	cin >> n >> m;

	//입력
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			char a;
			cin >> a;
			map[i][j] = a;
		}
	}
	//dfs 실행
	for(int i=0; i<n; i++){
		for(int j=0; j<m; j++){
			memset(check, false, sizeof(check));
			sx = i; sy = j;
			check[i][j]=true;
			int cnt =1;
			dfs(i,j, map[i][j], cnt);
			if(fin)
			{
				cout<<"Yes"<<endl;
				return 0;
			}
		}
	}
	cout << "No" << endl;
	return 0;
}


```


### 1767. [SW Test 샘플문제] 프로세서 연결하기

- N * N 의 행렬 (CORE 혹은 전선이 들어갈 수 있다.)
- (7<=N<=12), (1<=num of CORE<=12), 연결되지 않는 코어 허용
- 행렬의 가장자리에는 전원이 흐르고 있다. (가장자리에 위치한 코어는 전선이 필요없다.)
- core와 전원을 연결하는 전선은 직석으로만 설치가 가능하다.
- **전원은 교차할 수 없다**.
- 최대한 많은 Core에 전원을 연결한 경우 전선 길이의 합은?
(같은 Core 개수가 있다면 전선길이가 최소인 것을 출력)


> 방법 생각하기

- Core의 개수가 주어지므로 각 코어에서 DFS를 돌리면 될 것 같은데..
- 순차적으로 DFS/BFS를 진행하며 지나갔던 길은 `CHECK`한다.
- 문제는 DFS, BFS의 목적지 NODE를 무엇으로 하느냐 인 것 같다.
 
 >풀이 1. 선택한 `1`에서 갈 수 있는 모든 모서리를 다 본다.

 N의 최대가 12이므로 4^12 = 2^24 = 16777216(2천만) 타임아웃이 안난다.
 
 - 가장자리 코어는 따로 카운트
 - 나머지 코어에 들은 


> DFS부분부터 다시짜기

```c++

#include <iostream>
#include <string.h>

using namespace std;
int N, Answer;
bool map[13][13], check[13][13];
int dist[13];

bool isConnection(int x, int y, int i){

	//상,하,좌,우순으로 확인
	if(i==0)
	{
		for(int j=x+1; j<N; j++){
			if(map[j][y]) return false;
		}
		return true;
	}
	if(i==1)
	{
		for(int j=x-1; j>=0; j--){
			if(map[j][y]) return false;
		}
		return true;
	}
	if(i==2)
	{
		for(int j=y+1; j<N; j++){
			if(map[x][j]) return false;
		}
		return true;
	}
	if(i==3)
	{
		for(int j=x; j<N; j++){
			if(map[j][y]) return false;
		}
		return true;
	}

}

bool isEdge(int x, int y){
	if(x==0 || x==N-1 || y==0 || y==N-1 ) return true;
	else return false;
}


void init(){
	for(int j=0; j<N; j++){
		for(int k=0; k<N; k++){
			map[j][k]=false;
		}
	}
}

void dfs(int x, int y){

	//if(조건을 만족하면) 종료

	//전선은 오직 직선, 4방향 모두 확인
	for(int i=0; i<4; i++){
		//예외1. 현재 위치(x,y)가 가장자리인 경우
		if(isEdge(x,y))
		{
			return;
		}
		else
		{

		}
	}
}


int main(void){

	int test_case;
	cin >> test_case;

	//입력
	for(int i=0; i<test_case; i++){
		cin >> N;

		for(int j=0; j<N; j++){
			for(int k=0; k<N; k++){
				cin >> map[j][k];
			}
		}

		init();

		for(int j=0; j<N; j++){
			for(int k=0; k<N; k++){
				if(map[j][k]) dfs(j,k);
			}
		}

	}
}

```